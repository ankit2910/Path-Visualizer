{"ast":null,"code":"import _createForOfIteratorHelper from\"E:\\\\Projects\\\\pathvisualizer\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";// Returns all nodes in the order in which they were visited.\n// Make nodes point back to their previous node so that we can compute the shortest path\n// by backtracking from the finish node.\nexport function bfs(grid,startNode,finishNode){var visitedNodesInOrder=[];var nextNodesStack=[startNode];while(nextNodesStack.length){var currentNode=nextNodesStack.shift();if(currentNode===finishNode)return visitedNodesInOrder;if(!currentNode.isWall&&(currentNode.isStart||!currentNode.isVisited)){currentNode.isVisited=true;visitedNodesInOrder.push(currentNode);var col=currentNode.col,row=currentNode.row;var unvisitedNeighbors=getUnvisitedNeighbors(currentNode,grid);var _iterator=_createForOfIteratorHelper(unvisitedNeighbors),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var neighbor=_step.value;if(neighbor.isWall)continue;neighbor.distance=currentNode.distance+1;nextNodesStack.push(neighbor);neighbor.previousNode=currentNode;}}catch(err){_iterator.e(err);}finally{_iterator.f();}}}return visitedNodesInOrder;}function getUnvisitedNeighbors(node,grid){var neighbors=[];var col=node.col,row=node.row;if(row>0)neighbors.push(grid[row-1][col]);if(row<grid.length-1)neighbors.push(grid[row+1][col]);if(col>0)neighbors.push(grid[row][col-1]);if(col<grid[0].length-1)neighbors.push(grid[row][col+1]);return neighbors.filter(function(neighbor){return!neighbor.isVisited;});}","map":{"version":3,"names":["bfs","grid","startNode","finishNode","visitedNodesInOrder","nextNodesStack","length","currentNode","shift","isWall","isStart","isVisited","push","col","row","unvisitedNeighbors","getUnvisitedNeighbors","_iterator","_createForOfIteratorHelper","_step","s","n","done","neighbor","value","distance","previousNode","err","e","f","node","neighbors","filter"],"sources":["E:/Projects/pathvisualizer/src/algorithms/bfs.js"],"sourcesContent":["// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function bfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  let nextNodesStack = [startNode];\r\n  while (nextNodesStack.length) {\r\n    const currentNode = nextNodesStack.shift();\r\n    if (currentNode === finishNode) return visitedNodesInOrder;\r\n\r\n    if (\r\n      !currentNode.isWall &&\r\n      (currentNode.isStart || !currentNode.isVisited)\r\n    ) {\r\n      currentNode.isVisited = true;\r\n      visitedNodesInOrder.push(currentNode);\r\n      const {col, row} = currentNode;\r\n      const unvisitedNeighbors = getUnvisitedNeighbors(currentNode, grid);\r\n      for (const neighbor of unvisitedNeighbors) {\r\n        if(neighbor.isWall) continue;\r\n        neighbor.distance = currentNode.distance + 1;\r\n        nextNodesStack.push(neighbor);\r\n        neighbor.previousNode = currentNode;\r\n      }\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n"],"mappings":"0IAAA;AACA;AACA;AAEA,MAAO,SAAS,CAAAA,GAAGA,CAACC,IAAI,CAAEC,SAAS,CAAEC,UAAU,CAAE,CAC/C,GAAM,CAAAC,mBAAmB,CAAG,EAAE,CAC9B,GAAI,CAAAC,cAAc,CAAG,CAACH,SAAS,CAAC,CAChC,MAAOG,cAAc,CAACC,MAAM,CAAE,CAC5B,GAAM,CAAAC,WAAW,CAAGF,cAAc,CAACG,KAAK,CAAC,CAAC,CAC1C,GAAID,WAAW,GAAKJ,UAAU,CAAE,MAAO,CAAAC,mBAAmB,CAE1D,GACE,CAACG,WAAW,CAACE,MAAM,GAClBF,WAAW,CAACG,OAAO,EAAI,CAACH,WAAW,CAACI,SAAS,CAAC,CAC/C,CACAJ,WAAW,CAACI,SAAS,CAAG,IAAI,CAC5BP,mBAAmB,CAACQ,IAAI,CAACL,WAAW,CAAC,CACrC,GAAO,CAAAM,GAAG,CAASN,WAAW,CAAvBM,GAAG,CAAEC,GAAG,CAAIP,WAAW,CAAlBO,GAAG,CACf,GAAM,CAAAC,kBAAkB,CAAGC,qBAAqB,CAACT,WAAW,CAAEN,IAAI,CAAC,CAAC,IAAAgB,SAAA,CAAAC,0BAAA,CAC7CH,kBAAkB,EAAAI,KAAA,KAAzC,IAAAF,SAAA,CAAAG,CAAA,KAAAD,KAAA,CAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,EAA2C,IAAhC,CAAAC,QAAQ,CAAAJ,KAAA,CAAAK,KAAA,CACjB,GAAGD,QAAQ,CAACd,MAAM,CAAE,SACpBc,QAAQ,CAACE,QAAQ,CAAGlB,WAAW,CAACkB,QAAQ,CAAG,CAAC,CAC5CpB,cAAc,CAACO,IAAI,CAACW,QAAQ,CAAC,CAC7BA,QAAQ,CAACG,YAAY,CAAGnB,WAAW,CACrC,CAAC,OAAAoB,GAAA,EAAAV,SAAA,CAAAW,CAAA,CAAAD,GAAA,WAAAV,SAAA,CAAAY,CAAA,IACH,CACF,CACA,MAAO,CAAAzB,mBAAmB,CAC5B,CAEA,QAAS,CAAAY,qBAAqBA,CAACc,IAAI,CAAE7B,IAAI,CAAE,CACzC,GAAM,CAAA8B,SAAS,CAAG,EAAE,CACpB,GAAO,CAAAlB,GAAG,CAASiB,IAAI,CAAhBjB,GAAG,CAAEC,GAAG,CAAIgB,IAAI,CAAXhB,GAAG,CACf,GAAIA,GAAG,CAAG,CAAC,CAAEiB,SAAS,CAACnB,IAAI,CAACX,IAAI,CAACa,GAAG,CAAG,CAAC,CAAC,CAACD,GAAG,CAAC,CAAC,CAC/C,GAAIC,GAAG,CAAGb,IAAI,CAACK,MAAM,CAAG,CAAC,CAAEyB,SAAS,CAACnB,IAAI,CAACX,IAAI,CAACa,GAAG,CAAG,CAAC,CAAC,CAACD,GAAG,CAAC,CAAC,CAC7D,GAAIA,GAAG,CAAG,CAAC,CAAEkB,SAAS,CAACnB,IAAI,CAACX,IAAI,CAACa,GAAG,CAAC,CAACD,GAAG,CAAG,CAAC,CAAC,CAAC,CAC/C,GAAIA,GAAG,CAAGZ,IAAI,CAAC,CAAC,CAAC,CAACK,MAAM,CAAG,CAAC,CAAEyB,SAAS,CAACnB,IAAI,CAACX,IAAI,CAACa,GAAG,CAAC,CAACD,GAAG,CAAG,CAAC,CAAC,CAAC,CAChE,MAAO,CAAAkB,SAAS,CAACC,MAAM,CAAC,SAAAT,QAAQ,QAAI,CAACA,QAAQ,CAACZ,SAAS,GAAC,CAC1D"},"metadata":{},"sourceType":"module"}