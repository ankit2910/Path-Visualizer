{"ast":null,"code":"import _createForOfIteratorHelper from\"E:\\\\Projects\\\\pathvisualizer\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";// Returns all nodes in the order in which they were visited.\n// Make nodes point back to their previous node so that we can compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid,startNode,finishNode){var visitedNodesInOrder=[];startNode.distance=0;var unvisitedNodes=getAllNodes(grid);// Q: different from using grid or slice of grid???\nwhile(unvisitedNodes.length){sortNodesByDistance(unvisitedNodes);var closestNode=unvisitedNodes.shift();// If we encounter a wall, we skip it.\nif(!closestNode.isWall){// If the closest node is at a distance of infinity,\n// we must be trapped and should stop.\nif(closestNode.distance===Infinity)return visitedNodesInOrder;closestNode.isVisited=true;visitedNodesInOrder.push(closestNode);if(closestNode===finishNode)return visitedNodesInOrder;updateUnvisitedNeighbors(closestNode,grid);}}return visitedNodesInOrder;}function getAllNodes(grid){var nodes=[];var _iterator=_createForOfIteratorHelper(grid),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var row=_step.value;var _iterator2=_createForOfIteratorHelper(row),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var node=_step2.value;nodes.push(node);}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}}}catch(err){_iterator.e(err);}finally{_iterator.f();}return nodes;}function sortNodesByDistance(unvisitedNodes){unvisitedNodes.sort(function(nodeA,nodeB){return nodeA.distance-nodeB.distance;});}function updateUnvisitedNeighbors(node,grid){var unvisitedNeighbors=getUnvisitedNeighbors(node,grid);var _iterator3=_createForOfIteratorHelper(unvisitedNeighbors),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var neighbor=_step3.value;if(neighbor.isWall)continue;neighbor.distance=node.distance+1;neighbor.previousNode=node;}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}}function getUnvisitedNeighbors(node,grid){var neighbors=[];var col=node.col,row=node.row;if(row>0)neighbors.push(grid[row-1][col]);if(row<grid.length-1)neighbors.push(grid[row+1][col]);if(col>0)neighbors.push(grid[row][col-1]);if(col<grid[0].length-1)neighbors.push(grid[row][col+1]);return neighbors.filter(function(neighbor){return!neighbor.isVisited;});}","map":{"version":3,"names":["dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","getAllNodes","length","sortNodesByDistance","closestNode","shift","isWall","Infinity","isVisited","push","updateUnvisitedNeighbors","nodes","_iterator","_createForOfIteratorHelper","_step","s","n","done","row","value","_iterator2","_step2","node","err","e","f","sort","nodeA","nodeB","unvisitedNeighbors","getUnvisitedNeighbors","_iterator3","_step3","neighbor","previousNode","neighbors","col","filter"],"sources":["E:/Projects/pathvisualizer/src/algorithms/dijkstra.js"],"sourcesContent":["// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid); // Q: different from using grid or slice of grid???\r\n\r\n  while (unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (!closestNode.isWall) {\r\n      // If the closest node is at a distance of infinity,\r\n      // we must be trapped and should stop.\r\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      if (closestNode === finishNode) return visitedNodesInOrder;\r\n      updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    if(neighbor.isWall) continue;\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}