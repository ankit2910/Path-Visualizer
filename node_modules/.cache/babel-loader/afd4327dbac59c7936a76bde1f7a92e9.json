{"ast":null,"code":"// Returns all nodes in the order in which they were visited.\n// Make nodes point back to their previous node so that we can compute the shortest path\n// by backtracking from the finish node.\n\nexport function bfs(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  let nextNodesStack = [startNode];\n  while (nextNodesStack.length) {\n    const currentNode = nextNodesStack.shift();\n    if (currentNode === finishNode) return visitedNodesInOrder;\n    if (!currentNode.isWall && (currentNode.isStart || !currentNode.isVisited)) {\n      currentNode.isVisited = true;\n      visitedNodesInOrder.push(currentNode);\n      const {\n        col,\n        row\n      } = currentNode;\n      const unvisitedNeighbors = getUnvisitedNeighbors(currentNode, grid);\n      for (const neighbor of unvisitedNeighbors) {\n        if (neighbor.isWall) continue;\n        neighbor.distance = currentNode.distance + 1;\n        nextNodesStack.push(neighbor);\n        neighbor.previousNode = currentNode;\n      }\n    }\n  }\n  return visitedNodesInOrder;\n}\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const {\n    col,\n    row\n  } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}","map":{"version":3,"names":["bfs","grid","startNode","finishNode","visitedNodesInOrder","nextNodesStack","length","currentNode","shift","isWall","isStart","isVisited","push","col","row","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","distance","previousNode","node","neighbors","filter"],"sources":["E:/Projects/pathvisualizer/src/algorithms/bfs.js"],"sourcesContent":["// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function bfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  let nextNodesStack = [startNode];\r\n  while (nextNodesStack.length) {\r\n    const currentNode = nextNodesStack.shift();\r\n    if (currentNode === finishNode) return visitedNodesInOrder;\r\n\r\n    if (\r\n      !currentNode.isWall &&\r\n      (currentNode.isStart || !currentNode.isVisited)\r\n    ) {\r\n      currentNode.isVisited = true;\r\n      visitedNodesInOrder.push(currentNode);\r\n      const {col, row} = currentNode;\r\n      const unvisitedNeighbors = getUnvisitedNeighbors(currentNode, grid);\r\n      for (const neighbor of unvisitedNeighbors) {\r\n        if(neighbor.isWall) continue;\r\n        neighbor.distance = currentNode.distance + 1;\r\n        nextNodesStack.push(neighbor);\r\n        neighbor.previousNode = currentNode;\r\n      }\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;;AAEA,OAAO,SAASA,GAAGA,CAACC,IAAI,EAAEC,SAAS,EAAEC,UAAU,EAAE;EAC/C,MAAMC,mBAAmB,GAAG,EAAE;EAC9B,IAAIC,cAAc,GAAG,CAACH,SAAS,CAAC;EAChC,OAAOG,cAAc,CAACC,MAAM,EAAE;IAC5B,MAAMC,WAAW,GAAGF,cAAc,CAACG,KAAK,CAAC,CAAC;IAC1C,IAAID,WAAW,KAAKJ,UAAU,EAAE,OAAOC,mBAAmB;IAE1D,IACE,CAACG,WAAW,CAACE,MAAM,KAClBF,WAAW,CAACG,OAAO,IAAI,CAACH,WAAW,CAACI,SAAS,CAAC,EAC/C;MACAJ,WAAW,CAACI,SAAS,GAAG,IAAI;MAC5BP,mBAAmB,CAACQ,IAAI,CAACL,WAAW,CAAC;MACrC,MAAM;QAACM,GAAG;QAAEC;MAAG,CAAC,GAAGP,WAAW;MAC9B,MAAMQ,kBAAkB,GAAGC,qBAAqB,CAACT,WAAW,EAAEN,IAAI,CAAC;MACnE,KAAK,MAAMgB,QAAQ,IAAIF,kBAAkB,EAAE;QACzC,IAAGE,QAAQ,CAACR,MAAM,EAAE;QACpBQ,QAAQ,CAACC,QAAQ,GAAGX,WAAW,CAACW,QAAQ,GAAG,CAAC;QAC5Cb,cAAc,CAACO,IAAI,CAACK,QAAQ,CAAC;QAC7BA,QAAQ,CAACE,YAAY,GAAGZ,WAAW;MACrC;IACF;EACF;EACA,OAAOH,mBAAmB;AAC5B;AAEA,SAASY,qBAAqBA,CAACI,IAAI,EAAEnB,IAAI,EAAE;EACzC,MAAMoB,SAAS,GAAG,EAAE;EACpB,MAAM;IAACR,GAAG;IAAEC;EAAG,CAAC,GAAGM,IAAI;EACvB,IAAIN,GAAG,GAAG,CAAC,EAAEO,SAAS,CAACT,IAAI,CAACX,IAAI,CAACa,GAAG,GAAG,CAAC,CAAC,CAACD,GAAG,CAAC,CAAC;EAC/C,IAAIC,GAAG,GAAGb,IAAI,CAACK,MAAM,GAAG,CAAC,EAAEe,SAAS,CAACT,IAAI,CAACX,IAAI,CAACa,GAAG,GAAG,CAAC,CAAC,CAACD,GAAG,CAAC,CAAC;EAC7D,IAAIA,GAAG,GAAG,CAAC,EAAEQ,SAAS,CAACT,IAAI,CAACX,IAAI,CAACa,GAAG,CAAC,CAACD,GAAG,GAAG,CAAC,CAAC,CAAC;EAC/C,IAAIA,GAAG,GAAGZ,IAAI,CAAC,CAAC,CAAC,CAACK,MAAM,GAAG,CAAC,EAAEe,SAAS,CAACT,IAAI,CAACX,IAAI,CAACa,GAAG,CAAC,CAACD,GAAG,GAAG,CAAC,CAAC,CAAC;EAChE,OAAOQ,SAAS,CAACC,MAAM,CAACL,QAAQ,IAAI,CAACA,QAAQ,CAACN,SAAS,CAAC;AAC1D"},"metadata":{},"sourceType":"module"}